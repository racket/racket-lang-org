<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>New Contract-Related Features</title>
    <meta name="description" content="_posted by Stevie_  In SVN I've added three new major features that involve contracts. One allows for more fine-grained control of contracts, and the other two allow for the use of contracts with signatures and units.  Contract Regions:  _Contract regions...">
    <meta name="author"      content="The Unknown Author">
    <meta name="keywords"    content="">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://blog.racket-lang.org/2009/02/new-contract-related-features.html">
    <link rel="next" href="/2009/01/cfp-scheme-workshop-2009.html">
    <link rel="prev" href="/2009/02/steering-scheme.html">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/blog-fonts.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml" href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml" href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    </head>
  <body>
<row class="one-column" id="logo"><col-1><a href="http://racket-lang.org"><div><img class="legacy-logo" src="/img/logo-and-text-inverted.png"/></div></a></col-1><col-2><p><a href="/index.html">blog</a></p></col-2></row>
<article>
<row>

<col-1>
  <p class='date-and-tags'>14 Feb 2009</p>

</col-1>

<col-2>
  <header>
  <h1>New Contract-Related Features</h1>
  </header>

<p><em>posted by Stevie</em></p>

<p>In SVN I&rsquo;ve added three new major features that involve contracts. One allows for more fine-grained control of contracts, and the other two allow for the use of contracts with signatures and units.</p>

<h2 id="contract-regions">Contract Regions</h2>

<p><em>Contract regions</em> allow the programmer to protect a region of code with a contract boundary. In addition to the wrapped code, the programmer also provides a name for the region which is used in blame situations and a list of exported variables which can either be protected with contracts or unprotected. The region provides a true contract boundary, in that uses of contracted exports within the region are unprotected. Contract regions are specified with the <code>with-contract</code> form. The following contract region defines two mutually recursive functions:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">with-contract</span> <span class="n">region1</span>
 <span class="p">([</span><span class="n">f</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">number?</span> <span class="nb">boolean?</span><span class="p">)]</span>
  <span class="p">[</span><span class="n">g</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">number?</span> <span class="nb">boolean?</span><span class="p">)])</span>
 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">f</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zero?</span> <span class="n">n</span><span class="p">)</span> <span class="no">#f</span> <span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">n</span><span class="p">))))</span>
 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">g</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zero?</span> <span class="n">n</span><span class="p">)</span> <span class="no">#t</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">n</span><span class="p">)))))</span>
 <span class="o">```</span>

<span class="ss">The</span> <span class="n">internal</span> <span class="n">calls</span> <span class="n">to</span> <span class="o">`</span><span class="ss">f</span><span class="o">`</span> <span class="ss">and</span> <span class="o">`</span><span class="ss">g</span><span class="o">`</span> <span class="ss">are</span> <span class="n">uncontracted</span><span class="o">,</span> <span class="n">but</span> <span class="n">calls</span> <span class="n">to</span> <span class="o">`</span><span class="ss">f</span><span class="o">`</span><span class="ss">and</span> <span class="o">`</span><span class="ss">g</span><span class="o">`</span> <span class="ss">outside</span> <span class="k">this</span> <span class="n">region</span> <span class="n">would</span> <span class="n">be</span> <span class="n">appropriately</span> <span class="n">contracted.</span>  <span class="n">First-order</span> <span class="n">checks</span> <span class="n">are</span> <span class="n">performed</span> <span class="n">at</span> <span class="n">the</span> <span class="n">region</span><span class="o">,</span> <span class="n">so</span> <span class="n">the</span>
<span class="n">following</span> <span class="n">region:</span>

<span class="o">```</span><span class="ss">racket</span>
<span class="p">(</span><span class="k">with-contract</span> <span class="n">region2</span>
 <span class="p">([</span><span class="n">n</span> <span class="nb">number?</span><span class="p">])</span>
 <span class="p">(</span><span class="k">define</span> <span class="n">n</span> <span class="no">#t</span><span class="p">))</span>
 <span class="o">```</span>

<span class="ss">results</span> <span class="n">in</span> <span class="n">the</span> <span class="n">following</span> <span class="n">error:</span>

<span class="o">```</span><span class="ss">racket</span>
<span class="p">(</span><span class="n">region</span> <span class="n">region2</span><span class="p">)</span> <span class="n">broke</span> <span class="n">the</span> <span class="k">contract</span> <span class="nb">number?</span> <span class="n">on</span> <span class="n">n</span><span class="c1">; expected &lt;number?&gt;, given: #t</span>
</pre></div>

</div>

<p>Notice that the blame not only gives the name of the region, but describes what type of contract boundary was involved.</p>

<p>For contracting a single definition, there is the <code>define/contract</code> form which has a similar syntax to define, except that it takes a contract before the body of the definition.</p>

<p>To compare the two forms, the following two definitions are equivalent:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">with-contract</span> <span class="n">fact</span>
 <span class="p">([</span><span class="n">fact</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">number?</span> <span class="nb">number?</span><span class="p">)])</span>
 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">fact</span> <span class="n">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zero?</span> <span class="n">n</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="n">n</span> <span class="p">(</span><span class="n">fact</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">n</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define/contract</span> <span class="p">(</span><span class="n">fact</span> <span class="n">n</span><span class="p">)</span>
 <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">number?</span> <span class="nb">number?</span><span class="p">)</span>
 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zero?</span> <span class="n">n</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="n">n</span> <span class="p">(</span><span class="n">fact</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">n</span><span class="p">)))))</span>
</pre></div>

</div>

<p>First order checks are similarly performed at the definition for <code>define/contract</code>, so</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define/contract</span> <span class="p">(</span><span class="n">fact</span> <span class="n">n</span><span class="p">)</span>
 <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">number?</span><span class="p">)</span>
 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zero?</span> <span class="n">n</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="n">n</span> <span class="p">(</span><span class="n">fact</span> <span class="p">(</span><span class="nb">sub1</span> <span class="n">n</span><span class="p">)))))</span>
</pre></div>

</div>

<p>results in</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="n">function</span> <span class="n">fact</span><span class="p">)</span> <span class="n">broke</span> <span class="n">the</span> <span class="k">contract</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">number?</span><span class="p">)</span> <span class="n">on</span> <span class="n">fact</span><span class="c1">; expected a procedure that accepts no arguments without any keywords, given: #&lt;procedure:fact&gt;</span>
</pre></div>

</div>

<h2 id="signature-contracts">Signature Contracts</h2>

<p>In addition to contract regions, units are also now contract boundaries. One way to use contracts with units is to add contracts to unit signatures via the contracted <code>signature</code> form.</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define-signature</span> <span class="n">toy-factory^</span>
 <span class="p">((</span><span class="k">contracted</span>
   <span class="p">[</span><span class="n">build-toys</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">integer?</span> <span class="p">(</span><span class="nb">listof</span> <span class="n">toy?</span><span class="p">))]</span>
   <span class="p">[</span><span class="n">repaint</span>    <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span> <span class="n">toy?</span><span class="p">)]</span>
   <span class="p">[</span><span class="n">toy?</span>       <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">any/c</span> <span class="nb">boolean?</span><span class="p">)]</span>
   <span class="p">[</span><span class="n">toy-color</span>  <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span><span class="p">)])))</span>
</pre></div>

</div>

<p>Notice that contracts in a signature can use variables listed in the signature.Now if we take the following implementation of that signature:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define-unit</span> <span class="n">simple-factory@</span>
 <span class="p">(</span><span class="k">import</span><span class="p">)</span>
 <span class="p">(</span><span class="k">export</span> <span class="n">toy-factory^</span><span class="p">)</span>

 <span class="p">(</span><span class="k">define-struct</span> <span class="n">toy</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="kd">#:transparent</span><span class="p">)</span>

 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">build-toys</span> <span class="n">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">for/list</span> <span class="p">([</span><span class="n">i</span> <span class="p">(</span><span class="nb">in-range</span> <span class="n">n</span><span class="p">)])</span>
     <span class="p">(</span><span class="n">make-toy</span> <span class="o">&#39;</span><span class="ss">blue</span><span class="p">)))</span>

 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">repaint</span> <span class="n">t</span> <span class="n">col</span><span class="p">)</span>
   <span class="p">(</span><span class="n">make-toy</span> <span class="n">col</span><span class="p">)))</span>
</pre></div>

</div>

<p>We get the appropriate contract checks on those exports:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">define-values/invoke-unit/infer</span> <span class="n">simple-factory@</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="n">build-toys</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="ss">struct:toy</span> <span class="ss">blue</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="ss">struct:toy</span> <span class="ss">blue</span><span class="p">)</span> <span class="o">#</span><span class="p">(</span><span class="ss">struct:toy</span> <span class="ss">blue</span><span class="p">))</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="n">build-toys</span> <span class="no">#f</span><span class="p">)</span>
<span class="n">top-level</span> <span class="n">broke</span> <span class="n">the</span> <span class="k">contract</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">integer?</span> <span class="p">(</span><span class="nb">listof</span> <span class="n">toy?</span><span class="p">))</span>
 <span class="n">on</span> <span class="n">build-toys</span><span class="c1">; expected &gt;, given: #f</span>
</pre></div>

</div>

<p>As before, uses of contracted exports inside the unit are not checked.</p>

<p>Since units are contract boundaries, they can be blamed appropriately. Take the following definitions:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define-unit</span> <span class="n">factory-user@</span>
 <span class="p">(</span><span class="k">import</span> <span class="n">toy-factory^</span><span class="p">)</span>
 <span class="p">(</span><span class="k">export</span><span class="p">)</span>
 <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="n">toys</span> <span class="p">(</span><span class="n">build-toys</span> <span class="mi">3</span><span class="p">)])</span>
   <span class="p">(</span><span class="n">repaint</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="ss">blue</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define-compound-unit/infer</span> <span class="n">factory+user@</span>
 <span class="p">(</span><span class="k">import</span><span class="p">)</span> <span class="p">(</span><span class="k">export</span><span class="p">)</span>
 <span class="p">(</span><span class="k">link</span> <span class="n">simple-factory@</span> <span class="n">factory-user@</span><span class="p">))</span>
<span class="n">When</span> <span class="n">we</span> <span class="n">invoke</span> <span class="n">the</span> <span class="n">combined</span> <span class="n">unit:&gt;</span> <span class="p">(</span><span class="k">define-values/invoke-unit/infer</span> <span class="n">factory+user@</span><span class="p">)</span>
<span class="p">(</span><span class="k">unit</span> <span class="n">factory-user@</span><span class="p">)</span> <span class="n">broke</span> <span class="n">the</span> <span class="k">contract</span>
 <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span> <span class="n">toy?</span><span class="p">)</span>
<span class="n">on</span> <span class="n">repaint</span><span class="c1">; expected &gt;, given: 3</span>
</pre></div>

</div>

<h2 id="unit-contracts">Unit Contracts</h2>

<p>However, we may not always be able to add contracts to signatures. For example, there are many already-existing signatures in PLT Scheme that one may want to implement, or a programmer may want to take a unit value and add contracts to it after the fact.</p>

<p>To do this, there is the <code>unit/c</code> contract combinator. It takes a list of imports and exports, where each signature is paired with a list of variables and their contracts for each signature. So if we had the uncontracted version of the toy-factory^ signature:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define-signature</span> <span class="n">toy-factory^</span>
 <span class="p">(</span><span class="n">build-toys</span> <span class="n">repaint</span> <span class="n">toy?</span> <span class="n">toy-color</span><span class="p">))</span>
</pre></div>

</div>

<p>the following contracts would be appropriate for a unit that imports nothing and exports that signature:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">unit/c</span> <span class="p">(</span><span class="k">import</span><span class="p">)</span> <span class="p">(</span><span class="k">export</span><span class="p">))</span>
<span class="p">(</span><span class="k">unit/c</span> <span class="p">(</span><span class="k">import</span><span class="p">)</span> <span class="p">(</span><span class="k">export</span> <span class="n">toy-factory^</span><span class="p">))</span>
<span class="p">(</span><span class="k">unit/c</span>
 <span class="p">(</span><span class="k">import</span><span class="p">)</span>
 <span class="p">(</span><span class="k">export</span> <span class="p">(</span><span class="n">toy-factory^</span>
          <span class="p">[</span><span class="n">toy-color</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span><span class="p">)])))</span>
<span class="p">(</span><span class="k">unit/c</span>
 <span class="p">(</span><span class="k">import</span><span class="p">)</span>
 <span class="p">(</span><span class="k">export</span> <span class="p">(</span><span class="n">toy-factory^</span>
          <span class="p">[</span><span class="n">build-toys</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">integer?</span> <span class="p">(</span><span class="nb">listof</span> <span class="n">toy?</span><span class="p">))]</span>
          <span class="p">[</span><span class="n">repaint</span>    <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span> <span class="n">toy?</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">toy?</span>       <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">any/c</span> <span class="nb">boolean?</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">toy-color</span>  <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span><span class="p">)])))</span>
</pre></div>

</div>

<p>Unit contracts can contain a superset of the import signatures and a subset of the export signatures for a given unit value. Also, variables that are not listed for a given signature are left alone when the contracts are being added.</p>

<p>Since the results of applying <code>unit/c</code> is a new unit, then adding a contract can cause link inference to fail. For example, if we change the definition of <code>simple-factory@</code> above to</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define/contract</span> <span class="n">simple-factory@</span>
 <span class="p">(</span><span class="k">unit/c</span>
  <span class="p">(</span><span class="k">import</span><span class="p">)</span>
  <span class="p">(</span><span class="k">export</span> <span class="p">(</span><span class="n">toy-factory^</span>
           <span class="p">[</span><span class="n">build-toys</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">integer?</span> <span class="p">(</span><span class="nb">listof</span> <span class="n">toy?</span><span class="p">))]</span>
           <span class="p">[</span><span class="n">repaint</span>    <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span> <span class="n">toy?</span><span class="p">)]</span>
           <span class="p">[</span><span class="n">toy?</span>       <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">any/c</span> <span class="nb">boolean?</span><span class="p">)]</span>
           <span class="p">[</span><span class="n">toy-color</span>  <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span><span class="p">)])))</span>
 <span class="p">(</span><span class="k">unit</span>
   <span class="p">(</span><span class="k">import</span><span class="p">)</span>
   <span class="p">(</span><span class="k">export</span> <span class="n">toy-factory^</span><span class="p">)</span>

   <span class="p">(</span><span class="k">define-struct</span> <span class="n">toy</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="kd">#:transparent</span><span class="p">)</span>

   <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">build-toys</span> <span class="n">n</span><span class="p">)</span>
     <span class="p">(</span><span class="k">for/list</span> <span class="p">([</span><span class="n">i</span> <span class="p">(</span><span class="nb">in-range</span> <span class="n">n</span><span class="p">)])</span>
       <span class="p">(</span><span class="n">make-toy</span> <span class="o">&#39;</span><span class="ss">blue</span><span class="p">)))</span>

   <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">repaint</span> <span class="n">t</span> <span class="n">col</span><span class="p">)</span>
     <span class="p">(</span><span class="n">make-toy</span> <span class="n">col</span><span class="p">))))</span>
</pre></div>

</div>

<p>Then when we try to combine it with the <code>factory-user@</code> unit, we get:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="n">define-compound-unit/infer:</span> <span class="nb">not</span> <span class="n">a</span> <span class="k">unit</span> <span class="n">definition</span> <span class="n">in:</span> <span class="n">simple-factory@</span>
</pre></div>

</div>

<p>One way to solve this is to use <code>define-unit-binding</code> to set up the static information for the new contracted value. Another possibility for unit definitions is to use <code>define-unit/contract</code>:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span class="p">(</span><span class="k">define-unit/contract</span> <span class="n">simple-factory@</span>
 <span class="p">(</span><span class="k">import</span><span class="p">)</span>
 <span class="p">(</span><span class="k">export</span> <span class="p">(</span><span class="n">toy-factory^</span>
          <span class="p">[</span><span class="n">build-toys</span> <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">integer?</span> <span class="p">(</span><span class="nb">listof</span> <span class="n">toy?</span><span class="p">))]</span>
          <span class="p">[</span><span class="n">repaint</span>    <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span> <span class="n">toy?</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">toy?</span>       <span class="p">(</span><span class="k">-&gt;</span> <span class="nb">any/c</span> <span class="nb">boolean?</span><span class="p">)]</span>
          <span class="p">[</span><span class="n">toy-color</span>  <span class="p">(</span><span class="k">-&gt;</span> <span class="n">toy?</span> <span class="nb">symbol?</span><span class="p">)]))</span>

 <span class="p">(</span><span class="k">define-struct</span> <span class="n">toy</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="kd">#:transparent</span><span class="p">)</span>

 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">build-toys</span> <span class="n">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">for/list</span> <span class="p">([</span><span class="n">i</span> <span class="p">(</span><span class="nb">in-range</span> <span class="n">n</span><span class="p">)])</span>
     <span class="p">(</span><span class="n">make-toy</span> <span class="o">&#39;</span><span class="ss">blue</span><span class="p">)))</span>

 <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">repaint</span> <span class="n">t</span> <span class="n">col</span><span class="p">)</span>
   <span class="p">(</span><span class="n">make-toy</span> <span class="n">col</span><span class="p">)))</span>
</pre></div>

</div>

<p>More about these features can be found in the Reference, and a short section about signature and unit contracts has been added to the Guide.</p>
<col-2>

</row>

<footer>
<row>
<col-1>
</col-1>
<col-2>
<h2><span class="label">next</span> <a class="next" href="/2009/02/steering-scheme.html">Steering Scheme</a></h2>

<h2><span class="label">prev</span> <a class="previous" href="/2009/01/cfp-scheme-workshop-2009.html">CfP: Scheme Workshop 2009!</a></h2>

</col-2>
</row>
</footer>

</article>

<row class="one-column" id="bottom"><col-1></col-1><col-2>
<p>Made with <a href="https://github.com/greghendershott/frog">Frog</a>, a static-blog generator written in Racket.
<br /><a href="https://github.com/racket/racket-lang-org">Source code</a> for this blog.</col-2></row>
  </body>
</html>